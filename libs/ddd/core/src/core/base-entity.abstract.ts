import { IIdentifiable } from '../types/identifiable.interface'
import { IDomainObjectProps, DomainObject } from './domain-object.abstract'
import { UniqueID } from './unique-id'

export type IGenerator<T extends UniqueID> = () => T

// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface IEntityProps extends IDomainObjectProps {}

/**
 * @class Entity
 * @classdesc Entity is a base class for all domain entities.
 * Entity is a domain object that has a unique identifier.
 * Entity is a root of an aggregate.
 * Entities are compared by their unique identifiers.
 * Entities contain business logic.
 * Entities are persisted.
 * Entities are mutable.
 * Entities are not value objects, data transfer objects or aggregates.
 *
 * @see https://martinfowler.com/bliki/EvansClassification.html
 */

export abstract class BaseEntity<P extends IEntityProps, I extends UniqueID>
  extends DomainObject<P>
  implements IIdentifiable<I>
{
  public readonly id: I
  protected readonly _generator: IGenerator<I> = () => UniqueID.create() as I

  protected constructor(props: P, id?: I) {
    super(props, 'Entity')
    this.id = id ?? (this._generator() as I)
  }

  /**
   * @description Entities are compared by their id and class.
   * @returns true if the value objects are equal in value.
   */
  equals<E extends BaseEntity<P, I>>(entity: E): boolean {
    return this.isSameClass(entity) && this.id.equals(entity.id)
  }

  /**
   * @description Get an instance copy.
   * @returns a copy of the entity.
   */
  clone<E extends BaseEntity<P, I>>(): E {
    const constructor = Reflect.getPrototypeOf(this)?.constructor
    if (!constructor) throw new Error('Cannot clone entity')
    return Reflect.construct(constructor, [this.props, this.id.clone()])
  }
}

/**
 * Decorator used to set the id generator for an entity in the case
 * that other than the default UUID generator is needed.
 * A typical use case would be to use ObjectID from MongoDB instead of UUID.
 * In this case, you would need to create a custom generator that returns
 * ObjectID instead of UUID, where the ObjectID is generated by MongoDB and wrapped
 * in a ValueObject class.
 *
 * @example
 * @id(ObjectID.create)
 * class MyEntity extends BaseEntity<Props, ObjectID> {
 *   constructor(props: MyEntityProps, id?: ObjectID) {
 *     super(props, id)
 *   }
 * }
 *
 * @param generator A function that generates UniqueID values for the entity.
 * @returns class decorator
 */
export const unique = <I extends UniqueID>(generator: IGenerator<I>) =>
  function <
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
    T extends { new (...args: any[]): {} }
  >(EntityClass: T) {
    return class extends EntityClass {
      readonly id: ReturnType<typeof generator>
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      protected constructor(...[props, id]: any[]) {
        super(props)
        this.id = id ?? generator()
      }
    }
  }
